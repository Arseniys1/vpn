package handlers

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/rs/zerolog/log"

	"xray-vpn-connect/internal/models"
	"xray-vpn-connect/internal/services"
)

type ConnectionHandler struct {
	connectionService *services.ConnectionService
	userService       *services.UserService
}

func NewConnectionHandler(connectionService *services.ConnectionService, userService *services.UserService) *ConnectionHandler {
	return &ConnectionHandler{
		connectionService: connectionService,
		userService:       userService,
	}
}

func (h *ConnectionHandler) CreateConnection(c *gin.Context) {
	// Check authentication method
	authMethod, _ := c.Get("auth_method")

	var user *models.User
	var err error

	switch authMethod {
	case "telegram":
		telegramUserID, _ := c.Get("telegram_user_id")
		user, err = h.userService.GetUserByTelegramID(telegramUserID.(int64))
	case "browser":
		// For browser access, get user by ID
		userID, _ := c.Get("user_id")
		if userIDStr, ok := userID.(string); ok && userIDStr == "browser_user_123" {
			// Mock user for demonstration
			user = &models.User{
				ID:         uuid.New(),
				TelegramID: 123456789,
				FirstName:  "Browser",
			}
		}
	default:
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unknown authentication method"})
		return
	}

	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	var req struct {
		ServerID uuid.UUID `json:"server_id" binding:"required"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	connection, err := h.connectionService.CreateConnection(user.ID, req.ServerID)
	if err != nil {
		log.Error().Err(err).Msg("Failed to create connection")
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Return connection with generated temporary URLs
	// Note: Real URLs will be generated by worker service and updated via UpdateConnectionKey
	configURL := connection.ConnectionKey
	subscriptionURL := connection.SubscriptionLink

	// Generate temporary URLs if not yet created by worker
	if configURL == "" {
		configURL = "Connection being configured... Please refresh in a moment."
	}
	if subscriptionURL == "" {
		subscriptionURL = "Subscription link being generated... Please refresh in a moment."
	}

	response := gin.H{
		"id":               connection.ID,
		"server_id":        connection.ServerID,
		"config_url":       configURL,
		"subscription_url": subscriptionURL,
		"is_active":        connection.IsActive,
		"expires_at":       connection.ExpiresAt,
		"created_at":       connection.CreatedAt,
	}

	c.JSON(http.StatusOK, response)
}

func (h *ConnectionHandler) GetMyConnections(c *gin.Context) {
	// Check authentication method
	authMethod, _ := c.Get("auth_method")

	var user *models.User
	var err error

	switch authMethod {
	case "telegram":
		telegramUserID, _ := c.Get("telegram_user_id")
		user, err = h.userService.GetUserByTelegramID(telegramUserID.(int64))
	case "browser":
		// For browser access, get user by ID
		userID, _ := c.Get("user_id")
		if userIDStr, ok := userID.(string); ok && userIDStr == "browser_user_123" {
			// Mock user for demonstration
			user = &models.User{
				ID:         uuid.New(),
				TelegramID: 123456789,
				FirstName:  "Browser",
			}
		}
	default:
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unknown authentication method"})
		return
	}

	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	connections, err := h.connectionService.GetUserConnections(user.ID)
	if err != nil {
		log.Error().Err(err).Msg("Failed to get connections")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get connections"})
		return
	}

	// Enrich connections with status information
	type ConnectionResponse struct {
		ID              uuid.UUID  `json:"id"`
		ServerID        uuid.UUID  `json:"server_id"`
		ServerName      string     `json:"server_name"`
		ServerCountry   string     `json:"server_country"`
		ServerFlag      string     `json:"server_flag"`
		ConfigURL       string     `json:"config_url"`
		SubscriptionURL string     `json:"subscription_url"`
		IsActive        bool       `json:"is_active"`
		ExpiresAt       *time.Time `json:"expires_at"`
		CreatedAt       time.Time  `json:"created_at"`
		StatusMessage   string     `json:"status_message"`
	}

	response := make([]ConnectionResponse, 0, len(connections))
	for _, conn := range connections {
		statusMessage := "Active"
		if conn.ConnectionKey == "" {
			statusMessage = "Being configured... Please refresh in a moment."
		}

		response = append(response, ConnectionResponse{
			ID:              conn.ID,
			ServerID:        conn.ServerID,
			ServerName:      conn.Server.Name,
			ServerCountry:   conn.Server.Country,
			ServerFlag:      conn.Server.Flag,
			ConfigURL:       conn.ConnectionKey,
			SubscriptionURL: conn.SubscriptionLink,
			IsActive:        conn.IsActive,
			ExpiresAt:       conn.ExpiresAt,
			CreatedAt:       conn.CreatedAt,
			StatusMessage:   statusMessage,
		})
	}

	c.JSON(http.StatusOK, gin.H{"connections": response})
}

func (h *ConnectionHandler) DeleteConnection(c *gin.Context) {
	connectionID, err := uuid.Parse(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid connection ID"})
		return
	}

	if err := h.connectionService.DeleteConnection(connectionID); err != nil {
		log.Error().Err(err).Msg("Failed to delete connection")
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete connection"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Connection deleted successfully"})
}
